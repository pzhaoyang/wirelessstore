package com.uninet.xiaoyou.remotecontrol.utils;


import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;

import java.util.Locale;




import com.uninet.xiaoyou.remotecontrol.data.KeyValue;
import com.uninet.xiaoyou.remotecontrol.data.RemoteData;
import com.uninet.xiaoyou.remotecontrol.data.Value;
import com.uninet.xiaoyou.remotecontrol.database.IRDataBase;
import com.uninet.xiaoyou.remotecontrol.ircomm.RemoteComm;


import android.annotation.SuppressLint;
import android.content.Context;

import android.database.Cursor;

import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDatabase.CursorFactory;

import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;



/**
 * @author work
 *
 */
public class RemoteDB extends SQLiteOpenHelper {
	
	final static String TAG = "RemoteDB";

	
	final static String LIST_TAB	="remote";
	final static String BRAND_TAB	="brand";
	final static String KEY_TAB	="key_tab";
	
	private static final int DB_VERSION = 2;

	@SuppressLint("SdCardPath")
	private static String DB_PATH = "/data/data/com.uninet.xiaoyou.remotecontrol.remote/databases/";
	
	
	
	// private static String DB_PATH = android.os.Environment.getExternalStorageDirectory().getAbsolutePath()
	// + "/arthurcn/drivertest/packfiles/";
	
	private static String DB_NAME = "Remote.db";
	private static String ASSETS_NAME = "Remote.db";
	
	private SQLiteDatabase myDataBase;
	private final Context myContext;
	

//	private static final int ASSETS_SUFFIX_BEGIN = 100;

//	private static final int ASSETS_SUFFIX_END = 110;


	public RemoteDB(Context context, String name, CursorFactory factory, int version) {

		super(context, name, null, version);
		this.myContext = context;
	}
	
	public RemoteDB(Context context, String name, int version){
		this(context,name,null,version);
	}
	
	public RemoteDB(Context context, String name){
		this(context,name,DB_VERSION);
	}
	
	public RemoteDB (Context context) {
		this(context, DB_PATH + DB_NAME,DB_VERSION);
	}
	
	public void createDataBase() throws IOException{
		boolean dbExist = checkDataBase();
	//	 dbExist = checkDataBaseTime();
	//	if (dbExist==false){
		
	
		try {
			File dir = new File(DB_PATH);
			if(!dir.exists()){
			dir.mkdirs();
			}
			File dbf = new File(DB_PATH + DB_NAME);
			if(dbf.exists()){
			dbf.delete();
		}
		//	SQLiteDatabase.openOrCreateDatabase(dbf, null);
		
			copyDataBase();
			//copyBigDataBase();
			} catch (IOException e) {
			throw new Error("create database failed");
			}
		}
		
	//}

	
	private boolean checkDataBase(){
//		SQLiteDatabase checkDB = null;
		String myPath = DB_PATH + DB_NAME;
//		try{ 
//		checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);
//		}catch(SQLiteException e){
//		//database does't exist yet.
//		}
//		if(checkDB != null){
//		checkDB.close();
//		Log.v(TAG, "db  close");
//	
//		}
		File file=new File(myPath);
		if(file.exists()){
			return true;
		}else {
			return false;
		}
		
	}
	

//	private boolean checkDataBaseTime() throws IOException{
//		String myPath = DB_PATH + DB_NAME;
//		 
//	    File f = new File(myPath.toString());     
//	    long time1 = f.lastModified();  
//	    Log.v(TAG, "database modify time ====> "+ time1);
////	    String[] path= myContext.getAssets().list("");
////	    for (String p:path){
////	    Log.v(TAG, "assets databse modify path ====> "+p );
////	    }
////	    f = new File(path[0].toString());     
////	   
////	    long time2 = f.lastModified();  
//	    long time2 = Long.valueOf(ASSERT_TIME);
//	    Log.v(TAG, "assets databse modify time ====> "+ time2);
//	    if (time1==time2){
//	    return true;	
//	    }
//	    else{
//	    return false;	
//	    }
//		
//		
//	}
	  private byte[] InputStreamToByte(InputStream is) throws IOException {
	        ByteArrayOutputStream bytestream = new ByteArrayOutputStream();
	        int ch;
	        while ((ch = is.read()) != -1) {
	            bytestream.write(ch);
	        }
	        byte imgdata[] = bytestream.toByteArray();
	        bytestream.close();
	        return imgdata;
	    }
	
	public RemoteDB open(){
		String myPath = DB_PATH + DB_NAME;
	
		
		myDataBase = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);
	
		Log.v(TAG, "database opened");
		return this;
	
	}
	
	/**
	* Copies your database from your local assets-folder to the just created empty database in the
	* system folder, from where it can be accessed and handled.
	* This is done by transfering bytestream.
	* */
	private void copyDataBase() throws IOException{
		//Open your local db as the input stream
		InputStream myInput = myContext.getAssets().open(ASSETS_NAME);
		// Path to the just created empty db
		String outFileName = DB_PATH + DB_NAME;
		//Open the empty db as the output stream
		OutputStream myOutput = new FileOutputStream(outFileName);
		//transfer bytes from the inputfile to the outputfile
		byte[] buffer = new byte[1024];
		int length;
		while ((length = myInput.read(buffer))>0){
		myOutput.write(buffer, 0, length);
		}
		//Close the streams
		myOutput.flush();
		myOutput.close();
		myInput.close();
	}

//	//复制assets下的大数据库文件时用这个
//	private void copyBigDataBase() throws IOException{
//		InputStream myInput;
//		String outFileName = DB_PATH + DB_NAME;
//		OutputStream myOutput = new FileOutputStream(outFileName);
//		for (int i = ASSETS_SUFFIX_BEGIN; i < ASSETS_SUFFIX_END+1; i++) {
//		myInput = myContext.getAssets().open(ASSETS_NAME + "." + i);
//		byte[] buffer = new byte[1024];
//		int length;
//		while ((length = myInput.read(buffer))>0){
//		myOutput.write(buffer, 0, length);
//		}
//		myOutput.flush();
//		myInput.close();
//		}
//		myOutput.close();
//		Log.v(TAG, "database copy finished");
//		
//	}

	@Override
	public synchronized void close() {
		if(myDataBase != null){
		myDataBase.close();
		
		}
		super.close();
		Log.v(TAG, "database closed");
	}

	
	@Override
	public void onCreate(SQLiteDatabase db) {
	}

	/**
	* 数据库表结构有变化时采用
	*/
	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		 Log.w(TAG, "Upgrading database from version " + oldVersion
	                + " to " + newVersion + ".");

	        switch (oldVersion) {
	        case 0:
	            if (newVersion <= 1) {
	                return;
	            }

	            db.beginTransaction();
	            try {
	              //  upgradeDatabaseToVersion1(db);
	                db.setTransactionSuccessful();
	            } catch (Throwable ex) {
	                Log.e(TAG, ex.getMessage(), ex);
	                break;
	            } finally {
	                db.endTransaction();
	            }

	           return;
	    }

	    Log.e(TAG, "Destroying all old data.");
	   
	    onCreate(db);
	    try {
			copyDataBase();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	   
	}

	@SuppressWarnings("unused")
	private SQLiteDatabase openOrCreateDatabase(String string, Object object) {
	// TODO Auto-generated method stub
		return null;
	}

	public String[] getKeyValueTAB(int _type){
		String[] keyTable;
		Cursor c = myDataBase.query(KEY_TAB, null, " device_type =?",
				new String[] { String.valueOf(_type) }, null, null, null);

		Log.v(TAG, "device type ------>" + String.valueOf(_type));
	
		if (c.moveToFirst()) {
		int t=c.getCount();
		 keyTable = new String[t];
		int i = 0;
			do {
				keyTable[i] = c.getString(1);
				i++;
			} while (c.moveToNext());

		} else {
		 keyTable = new String[10];
		}
				
					
        c.close();
					
		return keyTable;
		
	}
	
	
	
	public  ArrayList<String> getCodeAll(String _type){
		
		ArrayList<String> codes =  new ArrayList<String>();
		Cursor c = myDataBase.query(LIST_TAB, null,  " type =?" ,new String[]{_type}, null, null, null);
	
		if (!c.moveToFirst()){
			Log.v(TAG, "get code error");
			 return null;
		}
		
		do{
			String code  = c.getString(3);  
		//	Log.v(TAG, "get code =====>"+ code);
			codes.add(code);	
		}while (c.moveToNext());
					
		c.close();			
		return codes;
		
	}
	
	
	
//	public String[] setKeyRemoteData(int _type,String _index){
//	//	ArrayList<RemoteData> rmtDts = new ArrayList<RemoteData>();
//		String[] rmtData = new String[50];
//		
//		Cursor c = myDataBase.query(Value.CodeProTab[_type], null,  " code_index =?" ,new String[]{_index}, null, null, null);
//		if (c==null){
//		return null;
//		}
//		c.moveToFirst();
//			//		Log.v(TAG, "columnCoutn data " + c.getColumnCount());
//		for (int i=4;i<c.getColumnCount();i++){
//		RemoteData rmtData1 = new RemoteData();
//		rmtData1.setCodetype(c.getString(2)) ; 
//		rmtData1.setCustom(c.getString(3)) ;
//		rmtData1.setData(c.getString(i)) ;
//				//	Log.v(TAG, "remote data " + rmtData.getRemoteData());
//		rmtData[i-4]=RemoteComm.encodeRemoteData(rmtData1);
//		}
//		
//	    c.close();
//		return rmtData;
//		
//	}

	
	
	public ArrayList<String> getBrand(String _type){
		ArrayList<String> brands =  new ArrayList<String>();
			//get all remote data
			Cursor c = myDataBase.query(LIST_TAB, null,  " type =?" ,new String[]{_type}, null, null, null);
			c.moveToFirst();
			
			do{
				String menufactory  = c.getString(1);  
				
					if (compareListValue(brands, menufactory)==-1){
			//			Log.v(TAG, "menufactory = " + menufactory);
						brands.add(menufactory);
						
					}
				}while (c.moveToNext());
			
			c.close();

		return brands;
		
	}
	
	public ArrayList<String> getAllBrand(){
		ArrayList<String> brands =  new ArrayList<String>();
			//get all remote data
			Cursor c = myDataBase.query(LIST_TAB, null, null ,null, null, null, null);
			c.moveToFirst();
			
			do{
				String menufactory  = c.getString(1);  
				
					if (compareListValue(brands, menufactory)==-1){
			//			Log.v(TAG, "menufactory = " + menufactory);
						brands.add(menufactory);
						
					}
				}while (c.moveToNext());
			
			c.close();

		return brands;
		
	}
	
	public String getBrandName(String _type,int _index){
		String brandName = null;
		
			Cursor c = myDataBase.query(BRAND_TAB, null,  " type =? and brand_code = ?" ,new String[]{_type,String.valueOf(_index)}, null, null, null);
		//	Cursor c = myDataBase.rawQuery("SELECT * FROM " + TV_CODE_TAB + " WHERE custom=20020080"   ,null);
			c.moveToFirst();
			brandName= c.getString(1);
			
			c.close(); 
		
		return brandName;
		
	}
	
	public ArrayList<String> getProducts(String deviceType,String _brandName){
		ArrayList<String> products =  new ArrayList<String>();
			Cursor c = myDataBase.query(LIST_TAB, null,  "brand =? and type = ? " ,new String[]{_brandName,deviceType}, null, null, null);
			c.moveToFirst();
			do{
				products.add(c.getString(2));
			}while(c.moveToNext());
			
			c.close(); 
			
		return products;
		
	}
	
	public ArrayList<String> getProductsIndex(String deviceType,String _brandName){
		ArrayList<String> products =  new ArrayList<String>();
			Cursor c = myDataBase.query(LIST_TAB, null,  "brand =? and type = ? " ,new String[]{_brandName,deviceType}, null, null, null);
			c.moveToFirst();
			do{
				products.add(c.getString(3));
			}while(c.moveToNext());
			
			c.close(); 
			
		return products;
		
	}
	
	public ArrayList<String> translateBrands(ArrayList<String> brands){
		ArrayList<String> newBrands =  new ArrayList<String>();
		String localeLanguage =Locale.getDefault().getLanguage();
		
		int column = 0;
		
				if (localeLanguage.equals("zh"))
				{
					column = 4;	//get brand chinese name
				}else if (localeLanguage.equals("tw"))
				{
					column = 3;	//get brand taiwan name
				}
				else
				{
					column = 2; //get brand english default name
				}
	//	Log.v(TAG, "get language  " + localeLanguage + "    column  " + column);		
		for (String brand :brands){
			
			Cursor c = myDataBase.query(BRAND_TAB, null,  "brand =?  " ,new String[]{brand}, null, null, null);
			if (c.moveToFirst()){
			//	Log.v(TAG, "cursor successed");
				byte[] val = c.getBlob(column);  
				if (val!=null&& localeLanguage.equals("zh")){
					try {
						newBrands.add(new String(val,"UTF-8"));
					} catch (UnsupportedEncodingException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}else {
					newBrands.add(c.getString(column));
				}

			
			}else {
				newBrands.add(brand);	
			}
			c.close(); 
		}
		
		
		return newBrands;
		
	}
	
	public String getBrandOriginal(String brandName){
		String brand = null;
		String localeLanguage =Locale.getDefault().getLanguage();
		Cursor c;
	
				if (localeLanguage.equals("zh"))
				{
					Log.v(TAG, localeLanguage);
					 c = myDataBase.query(BRAND_TAB, null,  "brand_zh =?  " ,new String[]{brandName}, null, null, null);
				}else if (localeLanguage.equals("tw"))
				{
					 c = myDataBase.query(BRAND_TAB, null,  "brand_tw =?  " ,new String[]{brandName}, null, null, null);
				}
				else
				{
					 c = myDataBase.query(BRAND_TAB, null,  "brand_en =?  " ,new String[]{brandName}, null, null, null);
				}
	
			
			
			if (c.moveToFirst()){
				Log.v(TAG, "cursor successed");
				
				brand =	c.getString(1);
				}

			
		
			c.close(); 
		
		
		
		return brand;
		
	}
	public ArrayList<KeyValue> getKeyInitialTable(){
			String keyName;
			Cursor c = myDataBase.query(KEY_TAB, null,  null ,null, null, null, null);
			c.moveToFirst();
			
				do {
				KeyValue kv = new KeyValue();
				keyName = c.getString(1);
				kv.setKeyName(keyName);
				kv.setDeviceType(c.getInt(2));
				kv.setKeyColumn(c.getInt(3));
			
				}while (c.moveToNext());

			c.close();
			return null; 
		
	}

	
	public int getKeyColumn(String keyName){
		int keyColumn = 0;
		
		Cursor c = myDataBase.query(KEY_TAB, null,  "name =?  " ,new String[]{keyName}, null, null, null);
		
		if (c.moveToFirst()){
			int index = c.getColumnIndex("key_column");
			keyColumn =	c.getInt(index);
		}
		c.close();
		
		return keyColumn; 
}
	
	/**
	 * compareListValue compare arraylist all members 
	 * @param datas
	 * @param data
	 * @return if get same members return >0 or no same member return -1
	 */
	public int compareListValue(ArrayList<String> datas,String data) {
		int i;
		for (i=0;i<datas.size();i++){
			if (datas.get(i).equals(data)){
				return i;
			}
		}
		return -1;
		
	}
	
	
	
}